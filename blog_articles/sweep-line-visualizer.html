<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sweep Line Algorithm Visualizer</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Source+Code+Pro:wght@500&display=swap" rel="stylesheet">

  <style>
    :root {
      --accent-primary: #BF092F;
      --accent-secondary: #FFDE4D;
      --sweep-line-color: #B4E380;
      --bg-canvas: #1A1A1D;
      --text-light: #e0e0e0;
      --text-dark: #FFFFFF;
      --border-color: #333;
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      min-height: 100vh; /* ✅ prevents zero height on mobile */
      overflow: hidden;
      font-family: 'Inter', sans-serif;
      color: var(--text-light);
      background-color: #121212;
    }

    body {
      display: flex;
      flex-direction: column;
      padding: 1rem;
      box-sizing: border-box;
    }

    #animation-wrapper {
      display: flex;
      gap: 1rem;
      flex-grow: 1;
      min-height: 0;
    }

    #sweep-line-canvas {
      flex: 3;
      background-color: var(--bg-canvas);
      border-radius: 8px;
      border: 1px solid var(--border-color);
      min-width: 0;
      height: 60vh; /* ✅ ensures visible area on phones */
      touch-action: none;
    }

    #status-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      background-color: var(--bg-canvas);
      border-radius: 8px;
      border: 1px solid var(--border-color);
      padding: 1rem;
      min-width: 150px;
    }

    #status-container h4 {
      margin: 0 0 0.75rem 0;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.75rem;
      color: #fff;
      font-size: 1rem;
      flex-shrink: 0;
    }

    #status-list {
      list-style-type: none;
      padding: 0;
      margin: 0;
      font-family: 'Source Code Pro', monospace;
      font-size: 0.9rem;
      overflow-y: auto;
      flex-grow: 1;
    }

    #controls {
      display: flex;
      justify-content: center;
      gap: 1rem;
      padding-top: 1rem;
      flex-shrink: 0;
    }

    button {
      font-weight: 600;
      padding: 12px 20px; /* ✅ larger for touch */
      border-radius: 8px;
      border: none;
      cursor: pointer;
      background-color: var(--accent-primary);
      color: var(--text-dark);
      touch-action: manipulation; /* ✅ proper touch click */
      pointer-events: auto;
      user-select: none;
    }

    @media (max-width: 600px) {
      #animation-wrapper {
        flex-direction: column;
      }
      #sweep-line-canvas {
        height: 50vh;
      }
    }
  </style>
</head>

<body>
  <div id="animation-wrapper">
    <svg id="sweep-line-canvas"></svg>
    <div id="status-container">
      <h4>Status (Active Segments)</h4>
      <ul id="status-list"></ul>
    </div>
  </div>

  <div id="controls">
    <button id="play-pause-btn">Play</button>
    <button id="reset-btn">Reset</button>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const svg = document.getElementById('sweep-line-canvas');
      const statusList = document.getElementById('status-list');
      const playPauseBtn = document.getElementById('play-pause-btn');
      const resetBtn = document.getElementById('reset-btn');
      const SVG_NS = 'http://www.w3.org/2000/svg';

      const SWEEP_LINE_COLOR = '#B4E380';
      const SEGMENT_COLOR = '#999';
      const EVENT_POINT_COLOR = '#fff';
      const ACTIVE_SEGMENT_COLOR = '#FFDE4D';

      let segments = [];
      let sweepLine;
      let currentX = 0;
      let isPlaying = false;
      let animationFrameId;

      function createSegment(id, x1, y1, x2, y2) {
        const line = document.createElementNS(SVG_NS, 'line');
        line.setAttribute('id', `segment-${id}`);
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        line.setAttribute('stroke', SEGMENT_COLOR);
        line.setAttribute('stroke-width', 2);
        return line;
      }

      function createEventPoint(x, y) {
        const circle = document.createElementNS(SVG_NS, 'circle');
        circle.setAttribute('cx', x);
        circle.setAttribute('cy', y);
        circle.setAttribute('r', 4);
        circle.setAttribute('fill', EVENT_POINT_COLOR);
        return circle;
      }

      function createSweepLine() {
        const line = document.createElementNS(SVG_NS, 'line');
        line.setAttribute('x1', 0);
        line.setAttribute('y1', 0);
        line.setAttribute('x2', 0);
        line.setAttribute('y2', '100%');
        line.setAttribute('stroke', SWEEP_LINE_COLOR);
        line.setAttribute('stroke-width', 2);
        line.setAttribute('stroke-dasharray', '5,5');
        return line;
      }

      function initialize() {
        if (!svg) return;
        svg.innerHTML = '';
        statusList.innerHTML = '';
        currentX = 0;
        isPlaying = false;
        playPauseBtn.textContent = 'Play';
        if (animationFrameId) cancelAnimationFrame(animationFrameId);

        const svgWidth = svg.clientWidth;
        const svgHeight = svg.clientHeight || window.innerHeight * 0.6; // ✅ fallback height

        segments = [
          { id: 1, x1: svgWidth * 0.1, y1: svgHeight * 0.25, x2: svgWidth * 0.5, y2: svgHeight * 0.4 },
          { id: 2, x1: svgWidth * 0.15, y1: svgHeight * 0.1, x2: svgWidth * 0.6, y2: svgHeight * 0.75 },
          { id: 3, x1: svgWidth * 0.2, y1: svgHeight * 0.6, x2: svgWidth * 0.75, y2: svgHeight * 0.25 },
          { id: 4, x1: svgWidth * 0.55, y1: svgHeight * 0.1, x2: svgWidth * 0.9, y2: svgHeight * 0.9 },
        ];

        segments.forEach(s => {
          const points = [{x: s.x1}, {x: s.x2}].sort((a,b) => a.x - b.x);
          s.startX = points[0].x;
          s.endX = points[1].x;
        });

        segments.forEach(s => {
          svg.appendChild(createSegment(s.id, s.x1, s.y1, s.x2, s.y2));
          svg.appendChild(createEventPoint(s.x1, s.y1));
          svg.appendChild(createEventPoint(s.x2, s.y2));
        });

        sweepLine = createSweepLine();
        svg.appendChild(sweepLine);
        updateStatus();
      }

      function updateStatus() {
        const activeSegments = [];
        segments.forEach(s => {
          if (currentX >= s.startX && currentX <= s.endX) {
            activeSegments.push(s);
          }
        });

        statusList.innerHTML = '';
        activeSegments.sort((a, b) => {
          const yA = a.y1 + (a.y2 - a.y1) * (currentX - a.x1) / (a.x2 - a.x1 || 1);
          const yB = b.y1 + (b.y2 - b.y1) * (currentX - b.x1) / (b.x2 - b.x1 || 1);
          return yA - yB;
        }).forEach(s => {
          const listItem = document.createElement('li');
          listItem.textContent = `Segment ${s.id}`;
          statusList.appendChild(listItem);
        });

        segments.forEach(s => {
          const line = document.getElementById(`segment-${s.id}`);
          const isActive = activeSegments.some(active => active.id === s.id);
          line.setAttribute('stroke', isActive ? ACTIVE_SEGMENT_COLOR : SEGMENT_COLOR);
          line.setAttribute('stroke-width', isActive ? 3 : 2);
        });
      }

      function animate() {
        if (!isPlaying) return;

        const svgWidth = svg.clientWidth;
        currentX += svgWidth / 500;
        sweepLine.setAttribute('x1', currentX);
        sweepLine.setAttribute('x2', currentX);

        updateStatus();

        if (currentX < svgWidth) {
          animationFrameId = requestAnimationFrame(animate);
        } else {
          isPlaying = false;
          playPauseBtn.textContent = 'Play';
        }
      }

      function handlePlayPause() {
        if (currentX >= svg.clientWidth) initialize();
        isPlaying = !isPlaying;
        playPauseBtn.textContent = isPlaying ? 'Pause' : 'Play';
        if (isPlaying) animate();
      }

      ['click', 'touchstart'].forEach(evt => {
        playPauseBtn.addEventListener(evt, handlePlayPause);
        resetBtn.addEventListener(evt, initialize);
      });

      let resizeTimeout;
      new ResizeObserver(() => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(initialize, 200);
      }).observe(svg);

      initialize();
    });
  </script>
</body>
</html>
