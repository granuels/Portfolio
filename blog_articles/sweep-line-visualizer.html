<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sweep Line Algorithm Visualizer</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Source+Code+Pro:wght@500&display=swap" rel="stylesheet">

  <style>
    :root {
      --accent-primary: #BF092F;
      --accent-secondary: #FFDE4D;
      --sweep-line-color: #B4E380;
      --bg-canvas: #1A1A1D;
      --text-light: #e0e0e0;
      --text-dark: #FFFFFF;
      --border-color: #333;
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      min-height: 100vh;
      overflow: hidden;
      font-family: 'Inter', sans-serif;
      color: var(--text-light);
      background-color: #121212;
    }

    body {
      display: flex;
      flex-direction: column;
      padding: 1rem;
      box-sizing: border-box;
    }

    #animation-wrapper {
      display: flex;
      gap: 1rem;
      flex-grow: 1;
      min-height: 0;
    }

    #sweep-line-canvas {
      flex: 3;
      background-color: var(--bg-canvas);
      border-radius: 8px;
      border: 1px solid var(--border-color);
      min-width: 0;
      height: 60vh;
      touch-action: none;
      display: block;
      width: 100%;
    }

    #status-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      background-color: var(--bg-canvas);
      border-radius: 8px;
      border: 1px solid var(--border-color);
      padding: 1rem;
      min-width: 150px;
    }

    #status-container h4 {
      margin: 0 0 0.75rem 0;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.75rem;
      color: #fff;
      font-size: 1rem;
      flex-shrink: 0;
    }

    #status-list {
      list-style-type: none;
      padding: 0;
      margin: 0;
      font-family: 'Source Code Pro', monospace;
      font-size: 0.9rem;
      overflow-y: auto;
      flex-grow: 1;
    }

    #controls {
      display: flex;
      justify-content: center;
      gap: 1rem;
      padding-top: 1rem;
      flex-shrink: 0;
      align-items: center;
    }

    button {
      font-weight: 600;
      padding: 12px 20px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      background-color: var(--accent-primary);
      color: var(--text-dark);
      touch-action: manipulation; /* prevents 300ms delay & ghost click */
      user-select: none;
      min-width: 96px;          /* âœ… fixed width prevents layout shift */
      text-align: center;
    }

    @media (max-width: 600px) {
      #animation-wrapper { flex-direction: column; }
      #sweep-line-canvas   { height: 50vh; }
    }
  </style>
</head>

<body>
  <div id="animation-wrapper">
    <svg id="sweep-line-canvas" preserveAspectRatio="none"></svg>
    <div id="status-container">
      <h4>Status (Active Segments)</h4>
      <ul id="status-list"></ul>
    </div>
  </div>

  <div id="controls">
    <button id="play-pause-btn">Play</button>
    <button id="reset-btn">Reset</button>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const svg = document.getElementById('sweep-line-canvas');
      const statusList = document.getElementById('status-list');
      const playPauseBtn = document.getElementById('play-pause-btn');
      const resetBtn = document.getElementById('reset-btn');
      const SVG_NS = 'http://www.w3.org/2000/svg';

      const SWEEP_LINE_COLOR = '#B4E380';
      const SEGMENT_COLOR = '#999';
      const EVENT_POINT_COLOR = '#fff';
      const ACTIVE_SEGMENT_COLOR = '#FFDE4D';

      // Logical drawing space (fixed). We scale to fit actual pixels.
      const VBW = 1000;
      const VBH = 600;

      let segmentsNorm = [
        // normalized [0..1] coords: easier to reflow on resize
        { id: 1, x1: 0.10, y1: 0.25, x2: 0.50, y2: 0.40 },
        { id: 2, x1: 0.15, y1: 0.10, x2: 0.60, y2: 0.75 },
        { id: 3, x1: 0.20, y1: 0.60, x2: 0.75, y2: 0.25 },
        { id: 4, x1: 0.55, y1: 0.10, x2: 0.90, y2: 0.90 },
      ];

      // Concrete segment objects in viewBox coords
      let segments = [];
      let sweepLine;
      let currentX = 0;       // in viewBox units (0..VBW)
      let isPlaying = false;
      let animationFrameId = null;

      // --- helpers
      function toVBX(v) { return v * VBW; }
      function toVBY(v) { return v * VBH; }

      function computeStartsEnds() {
        segments.forEach(s => {
          const points = [{x: s.x1}, {x: s.x2}].sort((a,b) => a.x - b.x);
          s.startX = points[0].x;
          s.endX   = points[1].x;
        });
      }

      function createLine(id, x1, y1, x2, y2) {
        const line = document.createElementNS(SVG_NS, 'line');
        line.setAttribute('id', `segment-${id}`);
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        line.setAttribute('stroke', SEGMENT_COLOR);
        line.setAttribute('stroke-width', 2);
        return line;
      }

      function createEventPoint(x, y) {
        const circle = document.createElementNS(SVG_NS, 'circle');
        circle.setAttribute('cx', x);
        circle.setAttribute('cy', y);
        circle.setAttribute('r', 4);
        circle.setAttribute('fill', EVENT_POINT_COLOR);
        return circle;
      }

      function ensureSweepLine() {
        if (!sweepLine) {
          sweepLine = document.createElementNS(SVG_NS, 'line');
          sweepLine.setAttribute('stroke', SWEEP_LINE_COLOR);
          sweepLine.setAttribute('stroke-width', 2);
          sweepLine.setAttribute('stroke-dasharray', '5,5');
          svg.appendChild(sweepLine);
        }
        sweepLine.setAttribute('x1', currentX);
        sweepLine.setAttribute('x2', currentX);
        sweepLine.setAttribute('y1', 0);
        sweepLine.setAttribute('y2', VBH);
      }

      function buildScene() {
        // Set a stable viewBox; avoid re-init on CSS/layout changes
        svg.setAttribute('viewBox', `0 0 ${VBW} ${VBH}`);
        svg.innerHTML = '';

        // Build segments in viewBox space from normalized
        segments = segmentsNorm.map(s => ({
          id: s.id,
          x1: toVBX(s.x1), y1: toVBY(s.y1),
          x2: toVBX(s.x2), y2: toVBY(s.y2)
        }));

        computeStartsEnds();

        // Draw segments + endpoints
        segments.forEach(s => {
          svg.appendChild(createLine(s.id, s.x1, s.y1, s.x2, s.y2));
          svg.appendChild(createEventPoint(s.x1, s.y1));
          svg.appendChild(createEventPoint(s.x2, s.y2));
        });

        ensureSweepLine();
      }

      function updateStatus() {
        const active = segments.filter(s => currentX >= s.startX && currentX <= s.endX);

        statusList.innerHTML = '';
        active.sort((a,b) => {
          const yA = a.y1 + (a.y2 - a.y1) * (currentX - a.x1) / (a.x2 - a.x1 || 1);
          const yB = b.y1 + (b.y2 - b.y1) * (currentX - b.x1) / (b.x2 - b.x1 || 1);
          return yA - yB;
        }).forEach(s => {
          const li = document.createElement('li');
          li.textContent = `Segment ${s.id}`;
          statusList.appendChild(li);
        });

        segments.forEach(s => {
          const line = document.getElementById(`segment-${s.id}`);
          const isActive = active.some(a => a.id === s.id);
          line.setAttribute('stroke', isActive ? ACTIVE_SEGMENT_COLOR : SEGMENT_COLOR);
          line.setAttribute('stroke-width', isActive ? 3 : 2);
        });
      }

      function animate() {
        if (!isPlaying) return;

        currentX += VBW / 500; // speed relative to logical width
        if (currentX > VBW) currentX = VBW;

        sweepLine.setAttribute('x1', currentX);
        sweepLine.setAttribute('x2', currentX);

        updateStatus();

        if (currentX < VBW) {
          animationFrameId = requestAnimationFrame(animate);
        } else {
          isPlaying = false;
          playPauseBtn.textContent = 'Play';
        }
      }

      function initialize() {
        // Reset state, but keep viewBox stable
        statusList.innerHTML = '';
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        currentX = 0;
        isPlaying = false;
        playPauseBtn.textContent = 'Play';
        buildScene();
        updateStatus();
      }

      function handlePlayPause(e) {
        e.preventDefault();
        if (currentX >= VBW) currentX = 0; // restart from beginning if at end
        isPlaying = !isPlaying;
        playPauseBtn.textContent = isPlaying ? 'Pause' : 'Play';
        if (isPlaying) animate();
      }

      function handleReset(e) {
        e.preventDefault();
        initialize();
      }

      // One clean event per button
      playPauseBtn.addEventListener('click', handlePlayPause, { passive: false });
      resetBtn.addEventListener('click', handleReset, { passive: false });

      // Preserve progress on any resize without re-initializing
      let lastClientWidth = svg.clientWidth || 1;
      window.addEventListener('resize', () => {
        // No re-init; just reflow SVG via viewBox scaling (already fixed),
        // and keep the same currentX in viewBox units. Nothing to do here.
        // The fixed button width also prevents most layout resizes on tap.
        lastClientWidth = svg.clientWidth || lastClientWidth;
      }, { passive: true });

      // First paint
      initialize();
    });
  </script>
</body>
</html>
